Notes - JavaScript v2 - Fundamentals

Functions in JavaScript are known as “First-Class”:
    * Functions can be stored as standalone functions (like above), as the value of variables,
        or as attributes in a JavaScript object (where they're known as methods)
    * Functions can be passed as arguments to functions (known as a callback)
    * Functions can be returned from functions. (This is creating what’s called a closure,
        which we’ll discuss later.)

Ternary operator: single line if-else check
    Ex: (condition) ? console.log(true) : console.log(false)

Do-while Loops:
    Ex:
        do {
            // CODE HERE
        } while (parent_permission)

Loops can be used on both arrays (by index), as well as objects (by key).
    Ex:
        for (var key in ninja) {
            if (ninja.hasOwnProperty(key)) {
                console.log(key);
                console.log(ninja[key]);
            }
        }

Arrays are generally used to keep track of a list of related things of the same type.
While objects are generally used to keep attributes of a thing associated with that thing.

=====================
| Function Hoisting |
=====================
This:
    awesome();
    function awesome() {
    console.log("too good to be true");
    }

Runs like this:
    // JS rearranges your code before running it
    function awesome() {     // the function floated to the top!
    console.log("too good to be true");
    }
    awesome();               // so now awesome is defined before we invoke it!

This:
    varFunction();
    var varFunction = function() {
      console.log("How will this get hoisted?")
    }

Runs like this:
    // HOW THE JS INTERPRETER REARRANGES THE CODE
    var varFunction;           // the variable declaration gets hoisted to the top
    varFunction();             // this tries to invoke "undefined": we get "undefined is not a function"
    varFunction = function() {
    console.log("How will this get hoisted?")
    }

====================
| Function Scoping |
====================

JavaScript has function scoping. What this means is that the variables that you declare with var inside a
function are accessible only inside the function they are declared in.

Understanding scope and how to use it and when and where variables are defined to structure our code will
make our JavaScript careers that much more awesome.

=================
| Organize Code |
=================
Example:

        // Overview: This function creates game objects, by returning a game object when invoked
        function GameConstructor(consumerPrice,dealerCost,name, inStock){
          // private variables
          // dealerCost is private so a buyer can't see our ridiculous markup!
          var consumerPrice = consumerPrice;
          var dealerCost = dealerCost;
          // if you are returning an object, set it as the last private variable
          var ourGame = {}; // end of private properties
          // public properties
          //_ signifies a field that we shouldn't modify, but is public
          ourGame._name = name;
          ourGame.type = 'board game';
          ourGame.player = [];
          // public methods can affect private variables!
          ourGame.addPlayer = function(player_name){
            ourGame.player.push(player_name);
          }
          ourGame.showPrivateVariables = function(){
            console.log(dealerCost);
            console.log(consumerPrice);
          }//end of methods


          //private methods :
          function myPrivateFunction(){
            console.log('hello, I am going to create a new object when I am returned!');
          }
          //End private methods
            // run events prior to construction if necessary
          myPrivateFunction();
          // return your final object (We will learn about other strategies to construct objects soon!)
          return ourGame;
        }

Even Better:
        /* **************** Game Constructor ******************
        private vars: consumerPrice, dealerCost
        private methods: myPrivateFunction: just console.logs, no logic
        public properties:  _name: acquired from parameters
                            type: constant, 'board game'
                            player: array


        public methods:     addPlayer: adds a player by name to player array
                            showPrivateVariables: console.logs our private variables
        on run: runs myPrivateFunction
        returns: ourGame object.
        *****************  END *******************/


        function GameConstructor(consumerPrice,dealerCost,name, inStock){


          var consumerPrice = consumerPrice;
          var dealerCost = dealerCost;
          var ourGame = {};


          ourGame._name = name;
          ourGame.type = 'board game';
          ourGame.player = [];


          ourGame.addPlayer = function(player_name){
            ourGame.player.push(player_name);
          }
          ourGame.showPrivateVariables = function(){
            console.log(dealerCost);
            console.log(consumerPrice);
          }


          function myPrivateFunction(){
            console.log('hello, I am going to create a new object when I am returned!');
          }


          myPrivateFunction();
          return ourGame;
        }

=======================
| Object Constructors |
=======================

Object constructors are functions that act as blueprints for creating particular objects.

Example:
        function NinjaConstructor(name, age, prevOccupation) {
          var ninja = {};     // the object that will eventually be returned
        /*
        Addition of properties to ninja.
        */
          ninja.name = name;
          ninja.age = age;
          ninja.prevOccupation = prevOccupation;
        /*
        Addition of methods to ninja
        */
          ninja.introduce = function() {
            console.log("Hi my name is " + ninja.name + ". I used to be a " + ninja.prevOccupation + " and now I'm a Ninja!");
          }
        /*
        return ninja
        */
          return ninja;
        }

                              // Create the Andrew Ninja
        var Andrew = NinjaConstructor("Andrew", 24, "Teacher");
        Andrew.introduce();
                              // Create the Michael Ninja
        var Michael = NinjaConstructor("Michael", 34, "Founder");
                              // here we redefine the introduce method for a particular "Instance" or Object
        Michael.introduce = function() {
          console.log("I am the Sensei!")
        }
        Michael.introduce();

We did a couple of things here:
    * Capitalized NinjaConstructor. This is a JavaScript convention to indicate that the function is an Object Constructor.
    * Created an object inside of the function and returned it. This is the specific instance of the object being created.
    * Redefined Michael’s introduce method (remember that these instances are just simple JavaScript objects,
        so we can manipulate them like we've always been able to)
